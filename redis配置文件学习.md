
学习一个中间件，先了解基本功能，然后通过配置文件学习是很好的方法
## Include

Redis 配置文件支持使用 `include` 指令来引入其他配置文件。这使得你可以将配置文件拆分成多个部分，便于管理和维护。

### **配置文件的加载顺序**

Redis 在加载配置文件时，会按照以下顺序处理：
1. **主配置文件**：首先加载主配置文件中的所有指令。
2. **`include` 引入的文件**：按照 `include` 指令的顺序，依次加载引入的配置文件。
3. **重复指令的处理**：如果在多个配置文件中存在相同的指令，Redis 会使用最后加载的配置文件中的值。

### Include使用
可以把模板文件当作启动配置，然后额外配置多个配置文件用于测试环境，开发环境等环境，然后根据需要加载对应配置文件。避免每次都要修改启动配置文件

### 4. **注意事项**

- **`CONFIG REWRITE` 命令**：`CONFIG REWRITE` 命令不会重写 `include` 指令。因此，如果你在运行时通过 `CONFIG REWRITE` 修改了配置，`include` 引入的配置文件不会被修改。
    
- **配置顺序**：由于 Redis 使用最后加载的配置值，建议将 `include` 指令放在主配置文件的开头，以避免运行时修改配置时出现意外覆盖。
    
- **覆盖配置**：如果你希望使用 `include` 来覆盖某些配置选项，建议将 `include` 指令放在主配置文件的末尾


## NETWORK
### bind

`bind` 配置项用于指定 Redis 服务器监听的 IP 地址。默认情况下，Redis 会监听所有可用的网络接口（即 `0.0.0.0`）。通过设置 `bind`，可以限制 Redis 仅监听指定的 IP 地址，从而提高安全性。

IPV4和IPV6可以混合配置

### protected-mode

默认值Yes
protected-mode为Yes的这种情况下：
- 如果没有通过 `bind` 指令明确绑定到特定 IP 地址，Redis 仅接受来自 `127.0.0.1` 和 `::1` 的连接。
- 如果没有配置密码，Redis 仅接受来自 `127.0.0.1` 和 `::1` 的连接。
### port
redis监听端口

### tcp-backlog

`tcp-backlog` 是 Redis 配置文件中的一个重要参数，用于控制 TCP 连接的监听队列大小。它是一个与操作系统相关的参数，用于指定在 Redis 服务器的 TCP 监听套接字上可以排队等待接受的最大连接数。

#### 作用
当客户端尝试连接到 Redis 服务器时，如果服务器当前正在处理其他连接请求，新的连接请求会被放入一个队列中等待处理。`tcp-backlog` 参数定义了这个队列的最大长度。如果队列已满，新的连接请求将被拒绝。

#### 注意事项
1. **操作系统限制**：
    - 操作系统可能会对 `tcp-backlog` 的最大值进行限制。例如，在 Linux 系统中，可以通过以下命令查看当前的限制值：
        ```bash
        sysctl net.core.somaxconn
        ```
        
    - 如果需要调整操作系统的限制值，可以使用以下命令：
        ```bash
        sysctl -w net.core.somaxconn=1024
        ```
        
2. **性能影响**：
    - 较大的 `tcp-backlog` 值可以减少连接被拒绝的情况，但也会增加服务器的内存使用量。因此，需要根据实际需求合理设置。
        
3. **高并发场景**：
    - 在**高并发场景下**，建议将 `tcp-backlog` 设置为一个较大的值，**以避免连接被拒绝**。例如，可以设置为 1024 或更高。

### timeout

客户端空闲超过timeout则自动关闭

### tcp-keepalive

redis心跳机制，用于检查tcp连接是否存活。定期发送心跳包，单位为秒


## GENERAL

1. **日志文件**：
    - 当 Redis 以守护进程模式运行时，建议指定一个日志文件，以便记录 Redis 的运行日志。例如：
        ```plaintext
        logfile /var/log/redis/redis-server.log
        ```
    - 如果不指定日志文件，Redis 的日志将输出到标准输出（通常是终端），这在守护进程模式下可能会导致日志丢失。
        
2. **PID 文件**：
    - 当 Redis 以守护进程模式运行时，建议指定一个 PID 文件，以便记录 Redis 进程的 PID。例如：
        ```plaintext
        pidfile /var/run/redis/redis-server.pid
        ```
    - 这有助于在需要时轻松找到 Redis 进程的 PID，例如在重启或停止 Redis 服务时。


### daemonize
`daemonize` 是 Redis 配置文件中的一个重要参数，用于控制 Redis 服务器是否以守护进程（daemon）模式运行。在守护进程模式下，Redis 会在后台运行，不会占用终端。

### pidfile

pid文件里面就是线程id（PID）

pid文件，只有守护进程执行时才会生成

#### PID 文件的作用
1. **进程管理**：
    
    - **启动服务**：在启动 Redis 服务时，Redis 会将当前进程的 PID 写入指定的 PID 文件。
        
    - **停止服务**：在停止 Redis 服务时，可以通过读取 PID 文件中的 PID 来找到 Redis 进程，并发送信号（如 `SIGTERM` 或 `SIGKILL`）来停止服务。
        
    - **重启服务**：在重启 Redis 服务时，同样可以通过 PID 文件找到当前运行的 Redis 进程并进行操作。
        
2. **监控和日志**：
    
    - **监控工具**：许多监控工具和脚本会使用 PID 文件来检查 Redis 服务是否正在运行。
        
    - **日志记录**：在某些情况下，PID 文件可以用于日志记录，以便在出现问题时快速定位 Redis 进程。

#### 如果 PID 文件已存在

如果指定的 PID 文件路径已经存在，Redis 会尝试读取该文件中的 PID，并检查是否存在一个 Redis 进程正在运行。具体行为如下：

1. **文件存在但内容为空**：
    - Redis 会忽略文件内容，将当前进程的 PID 写入文件。    
2. **文件存在且包含有效 PID**：
    - Redis 会尝试检查该 PID 是否对应一个正在运行的 Redis 进程。
    - 如果存在一个正在运行的 Redis 进程，Redis 会拒绝启动，并报错提示 PID 文件已存在且对应的进程正在运行。
    - 如果文件中的 PID 对应的进程已经不存在（例如，进程被手动停止），Redis 会覆盖该文件，将当前进程的 PID 写入文件。


### logfile

redis运行日志存放的日志位置，不配置则默认终端输出，如果是守护线程则忽略-既/dev/null

### loglevel
redis打印日志的级别
- debug
- verbose
- notice
- warning
### databases

通过数据库Id，用于逻辑隔离数据

`databases` 配置项用于指定 Redis 实例中可以使用的数据库数量。虽然 Redis 默认支持多个数据库，但在生产环境中，建议将每个应用程序或服务的数据存储在独立的 Redis 实例中，**以避免潜在的键名冲突和资源隔离问题**。在开发和测试环境中，可以使用多个数据库来逻辑分隔不同的数据集。

## SNAPSHOTTING

RDB文件：
RDB（Redis DataBase）文件是 Redis 在指定时间间隔内生成的内存数据快照，以二进制格式保存。RDB 文件的主要内容包括以下几个部分：
- **文件头**：
    - 包含 `REDIS` 标识符，表示这是一个 RDB 文件。
    - 包含 RDB 文件的版本号。
- **数据库数据**：
    - 每个数据库的数据以 `SELECT-DB` 开头，后面跟着数据库编号。
    - 每个键值对包含键的长度、键的内容、值的类型和值的内容。
    - 如果键有设置过期时间，还会包含过期时间（以毫秒为单位的 UNIX 时间戳）。    
- **文件尾**：
    - 包含一个 8 字节的校验和，用于检测文件是否被修改。

因为是二进制文件，可以通过工具解析
###  **RDB 文件与 AOF 文件的比较**

| 特性         | RDB 文件                | AOF 文件              |
| ---------- | --------------------- | ------------------- |
| **文件格式**   | 二进制                   | 文本                  |
| **文件大小**   | 通常较小                  | 通常较大                |
| **启动加载速度** | 快                     | 慢                   |
| **数据安全性**  | 可能丢失数据（取决于快照频率）       | 高安全性（除非配置了不同步磁盘）    |
| **磁盘 I/O** | 快照创建时较高               | 持续较低                |
| **适用场景**   | 数据不频繁更新，对数据完整性要求不高的场景 | 数据更新频繁，对数据完整性要求高的场景 |
| **恢复速度**   | 快                     | 慢                   |
| **缺点**     | 可能会丢失数据               | 文件可能会变得很大，影响性能      |
###  **混合持久化**

Redis 4.0 引入了混合持久化策略，结合了 RDB 和 AOF 的优点。混合持久化的工作原理如下：

- **文件结构**：
    - 文件的前半部分是 RDB 格式的快照，记录了当前数据的状态。
    - 文件的后半部分是 AOF 格式的写操作日志，记录了快照之后的写操作。
        
- **优点**：
    - **更快的启动速度**：结合了 RDB 的快速恢复能力。
    - **数据安全**：利用 AOF 的方式，即使服务器突然断电，也只会丢失极短时间内的数据。
    - **文件更小巧**：结合了 RDB 和 AOF 的优势，控制了文件大小和冗余度。
        
- **缺点**：
    - **稍微复杂**：处理起来比单一的 RDB 或 AOF 要复杂一点。
    - **可能占更多空间**：在某些情况下，保存数据的文件可能会比只使用 RDB 或 AOF 的文件要大一些。
    - **写入速度**：可能会稍慢一些，特别是当数据需要经常被保存到硬盘时（比如当 `appendfsync` 配置为 `always` 时）。
### save

如果不启用RDB则注释掉或者配置空字符串即可

RDB（redis database）持久化机制，通过下面两个配置来触发RDB事件。
- 时间间隔
- 写事件数目

### stop-writes-on-bgsave-error

`stop-writes-on-bgsave-error` 是 Redis 配置文件中的一个参数，用于控制在 RDB 持久化过程中，如果后台保存操作（`BGSAVE`）失败时，Redis 是否停止接受写操作。这个配置项的目的是确保用户在数据无法正确持久化到磁盘时能够及时发现问题，从而避免数据丢失。

配置yes，表示如果最近异常BGSAVE失败，则redis停止写入操作。


### rdbcompression

rdb文件压缩，默认开启。 关闭会节省一定cpu但是磁盘占用更多。

### rdbchecksum

检查rdb文件是否完整。

### dbfilename

RDB文件名

### dir

RDB文件目录

### `rdb-del-sync-files`

`rdb-del-sync-files` 是 Redis 配置文件中的一个选项，主要用于控制是否删除用于主从复制的 RDB 文件。

这个配置项只有RDB和AOF都没配置时生效

### 作用
- **删除同步文件**：在主从复制过程中，主节点会生成一个 RDB 文件并将其发送给从节点，以帮助从节点进行数据同步。如果设置了 `rdb-del-sync-files yes`，并且主节点没有启用 RDB 和 AOF 持久化，那么在同步完成后，Redis 会自动删除这些用于复制的 RDB 文件。
- **默认值**：默认值为 `no`，即在同步完成后不会自动删除这些 RDB 文件。

## REPLICATION

### replica-serve-stale-data

`replica-serve-stale-data` 决定了当从服务器与主服务器断开连接时，从服务器是否继续对外提供服务（即是否继续响应客户端的读请求）。

- **如果设置为 `yes`**：
    
    - 从服务器会在与主服务器断开连接后，继续对外提供服务。
        
    - 客户端仍然可以读取从服务器上的旧数据（stale data）。这些数据可能已经不是最新的，因为从服务器无法从主服务器获取最新的数据更新。
        
    - 这种设置适用于对数据一致性要求不高的场景，例如在读多写少的环境中，允许从服务器继续提供服务可以提高系统的可用性。
        
- **如果设置为 `no`**：
    
    - 从服务器在与主服务器断开连接后，会拒绝所有客户端的读请求。
        
    - 客户端会收到错误信息，例如 `READONLY You can't write against a read only replica.`（虽然这里提示的是写入错误，但实际是拒绝所有请求）。
        
    - 这种设置适用于对数据一致性要求较高的场景，确保客户端不会读取到过时的数据。

### `replica-serve-stale-data` 决定了当从服务器与主服务器断开连接时，从服务器是否继续对外提供服务（即是否继续响应客户端的读请求）。

- **如果设置为 `yes`**：
    - 从服务器会在与主服务器断开连接后，继续对外提供服务。
    - 客户端仍然可以读取从服务器上的旧数据（stale data）。这些数据可能已经不是最新的，因为从服务器无法从主服务器获取最新的数据更新。
    - 这种设置适用于对数据一致性要求不高的场景，例如在读多写少的环境中，允许从服务器继续提供服务可以提高系统的可用性。
        
- **如果设置为 `no`**：
    - 从服务器在与主服务器断开连接后，会拒绝所有客户端的读请求。
    - 客户端会收到错误信息，例如 `READONLY You can't write against a read only replica.`（虽然这里提示的是写入错误，但实际是拒绝所有请求）。

### replica-read-only
- 这个配置项决定了从服务器是否允许写操作。默认情况下，从服务器是只读的，客户端不能在从服务器上执行写操作。
- 如果你希望从服务器在某些情况下允许写操作，可以将 `replica-read-only` 设置为 `no`，但这通常不推荐，因为可能会导致数据不一致。

### repl-diskless-sync

`repl-diskless-sync` 决定了在**主从复制的全量同步**阶段，主节点是否使用无盘同步（diskless sync）的方式。

- **无盘同步（Diskless Sync）**：
    
    - 在无盘同步模式下，主节点不会先将数据写入磁盘生成 RDB 文件，而是直接通过网络将数据传输给从节点。
        
    - 这种方式避免了磁盘 I/O 操作，可以显著提高同步效率，尤其是在磁盘性能较差但网络带宽充足的情况下。
        
- **磁盘同步（Disk-backed Sync）**：
    
    - 在传统的磁盘同步模式下，主节点会先通过 `bgsave` 创建一个 RDB 文件并写入磁盘，然后再将该文件传输给从节点。
        
    - 这种方式的优点是稳定可靠，但会受到磁盘性能的限制。

### repl_ping_replica_period

`repl-ping-replica-period` 用于设置主节点向从节点发送 PING 命令的时间间隔，以检测从节点是否仍然存活。这是一个心跳机制，用于监控主从节点之间的连接状态。

### repl-timeout

`repl-timeout` 用于设置主节点在主从复制过程中等待从节点响应的最大时间（以秒为单位）。如果在指定的时间内，主节点没有收到从节点的响应，则认为从节点已经离线。

 **配置建议**
- **数据量较大时**：如果主节点的数据量较大，同步过程可能需要更长时间，建议将 `repl-timeout` 的值设置得更大一些，例如 600 秒。
- **网络不稳定时**：如果主从节点之间的网络环境不稳定，建议适当增加 `repl-timeout` 的值，以避免因网络延迟导致的误判。

 **注意事项**
- **与 `repl-ping-replica-period` 配合**：`repl-ping-replica-period` 是主节点向从节点发送心跳的时间间隔，默认为 10 秒。`repl-timeout` 的值应大于 `repl-ping-replica-period`，以避免频繁超时。
- **避免过小值**：如果 `repl-timeout` 设置得过小，可能会导致主节点频繁判定从节点离线，从而影响主从复制的稳定性

### repl-backlog-size

`repl-backlog-size` 设置了主节点维护的环形缓冲区的大小，该缓冲区用于存储主节点在主从复制过程中接收的写操作命令。当主从连接断开后重新连接时，从节点可以通过部分重同步（Partial Resynchronization）机制，从这个缓冲区中获取断开期间错过的变化。
 **注意事项**
- **内存占用**：`repl-backlog-size` 的值越大，主节点占用的内存也越多。因此，需要根据服务器的内存资源合理配置。
- **全量同步风险**：如果 `repl-backlog-size` 设置过小，从节点在断开重连时可能会因为缓冲区数据不足而无法进行部分重同步，从而触发全量同步，这会增加主节点的负载并可能导致性能下降。


### repl-backlog-ttl

`repl-backlog-ttl` 设置了复制积压缓冲区的存活时间（以秒为单位）。当主节点的复制积压缓冲区中的数据在指定的时间内没有被从节点取走时，这些数据将被移除。

### replica-priority
在 Redis Sentinel 模式下，当主节点（master）发生故障时，哨兵会自动进行故障转移，选择一个从节点提升为新的主节点。`replica-priority` 参数决定了从节点在故障转移时的优先级
- **数值越小，优先级越高**。例如，优先级为 `10` 的从节点比优先级为 `100` 的从节点更有可能被选为新的主节点。
- **设置为 `0` 的从节点永远不会被提升为新的主节点**。

### min-replicas-to-write，min-replicas-max-lag

min-replicas-to-write可以设置少于多少个slave节点回复，则否则拒绝后续写操作

`min-replicas-max-lag` 用于设置主节点在执行写操作时，允许从节点的最大延迟时间（以秒为单位）。当主节点的写操作需要等待至少 `min-replicas-to-write` 个从节点确认时，这些从节点的延迟时间不能超过 `min-replicas-max-lag` 秒。

#### 关于写操作的执行和确认

- **主节点的写操作**：主节点在执行写操作时，会将这些操作异步地发送给从节点。从节点会尝试执行这些操作以保持与主节点的数据同步。
- **确认机制**：主节点会等待从节点的确认（ACK）消息，以确保写操作被成功复制。
- **超时处理**：如果从节点的延迟（即从主节点发送写操作到从节点确认的时间）超过了 `min-replicas-max-lag` 配置的值，主节点会认为该从节点未能及时响应。
#### 如果从节点超时，写操作会如何处理？

- **写操作不会回滚**：主节点的写操作是独立执行的，不会因为从节点的延迟而回滚。主节点会继续执行写操作，并将结果存储在本地。
    
- **写操作可能失败**：如果主节点在执行写操作时，无法在 `min-replicas-max-lag` 指定的时间内收到至少 `min-replicas-to-write` 个从节点的确认，主节点会拒绝该写操作，并返回错误。

#### 总结
- 主节点不会因为从节点的写入超时而回滚写操作，但会根据 `min-replicas-to-write` 和 `min-replicas-max-lag` 的配置决定是否接受后续写操作。
- 主节点会持续尝试将数据同步到从节点，即使从节点的延迟超过 `min-replicas-max-lag`
## KEYS TRACKING

### tracking-table-max-keys

`tracking-table-max-keys 1000000`

设定redis能保存tracking-key的最大值，超过这个值，会导致缓存的key被强制失效掉

#### 客户端缓存
redis 6提供了Client side caching，其实就是内存缓存，将redis中部分数据缓存在内存中（客户端），这样就无需访问redis就能获取缓存数据。 redis需要订阅这些键，当发送键发生变化的时候通知客户端更新。

优点：
- 减少访问缓存时延
- 减少redis访问压力

redis如何实现客户端缓存？
两个模式
- 默认模式： redis记住客户端缓存的key，然后当key发生变化时，通知到缓存此key的客户端。
- 广播模式：redis不记住客户端缓存的key，而是客户端订阅要缓存key的前缀，当前缀key发生变化时候，收到通知
默认模式会增加redis的内存使用，因为要记住key:客户端

默认模式具体过程：
1. 客户端开启key tracking（客户端缓存），服务器记住这个key和对应客户端
2. 当key被其他客户端修改，或者过期，或者因为内存策略被逐出，服务端会对客户端发送tracking key失效的消息
3. 客户端收到消息，会删除本地缓存的key

## clients

### maxclients

允许客户端能同时连接的最大数量，如果超过这个数目，redis会拒绝新建的连接


## MEMORY MANAGEMENT

### maxmemory
maxmemory：设置redis占用的最大内存

如果内存超过maxmemory，且策略是不清除，则对于部分写请求set，lpush等，redis都会拒绝，但允许读访问


设置这个值，某些场景下需要注意：
主从复制模型下，redis中存储一个输出缓存区，用于存储要复制给从节点的命令。这个输出缓冲区也会占用内存。存在一种情况，redis内存不够的时候，如果选择的eviction策略，那会导致大量数据被清除，这些清除操作会写入输出缓冲区中导致内存进一步占用大，然后redis不停的清除，直到数据库都被清空


### maxmemory-policy

当内存达到最大的时候，清除内存的策略
- LRU
- LFU
- TTL：选择生存时间最小的淘汰
- Random
- NoEviction： 不淘汰，拒绝写入操作

具体策略
- volatile： 只处理设置了ttl（过期时间）的key
- allkey：所有key都处理


### maxmemory-samples

在策略选择：LRU，LFU，TTL中，如果每次都要在所有key中计算出要淘汰的key有些过于占用CPU，为了减少cpu的占用，Redis采用取样的算法。每次从要检查的key中取样maxmemory-samples配置数目，然后在其中找要删除的key。

在LRU，LFU中， redis压缩了存储时间/频率的结构，占用内存也会更小一些

按照配置项描述3-10是合理范围，10比较精确，3比较占用少cpu，比较快

### replica-ignore-maxmemory


默认备机不处理maxmemory配置，保持主备一致，replica-ignore-maxmemory为yes，只能是主机del掉命令然后发送给备机

特定情况下配置no，但如果memory配置比master小，会导致备机自己执行del操作，导致主备不一致

### active-expire-effort

主动过期机制：redis中键有ttl，到期后不会立刻被删除，而是等后台线程expire cycle通过检查内存中键来做清除

active-expire配置来调整主动过期机制的努力程度。这个配置项范围为1-10，1表示正常的努力程度，平衡了检查和过期。10表示非常努力，积极清理过期键，但会消耗更多的cpu资源，可能导致写入的延迟更高。
##  LAZY FREEING

redis中对于删除键提供两种方式
- del：阻塞删除，既在处理删除命令前会停止新命令，常用来删除小对象，时间一般为为logn或者n
- unlink：非阻塞删除，会立刻返回，但是会启动一个后台线程来删除，不会阻塞主线程
- FLUSHALL 清空所有键
	- async 异步，非阻塞
	- 默认阻塞删除所有键

如下可以配置删除方式，no表示阻塞删除，yes表示非阻塞删除
lazyfree-lazy-eviction：  内存满了，驱逐策略方式
lazyfree-lazy-expire： key失效方式
lazyfree-lazy-server-del： 执行del命令方式
replica-lazy-flush no： 执行flush命令方式

## THREADED I/O 

redis基本是单线程操作，避免并发操作带来的锁/线程切换等开销。但对于速度很慢的IO操作就是多线程的，例如unlink就是线程级操作。

IO多线程作用：
- 支持多线程的读写操作，将读写操作分配给不同的IO线程，提高吞吐，特别是写命令比较慢时
- 性能提示，相比命令管道（pipelining）或实例分片（sharding）。提供额外IO线程处理能更好提供性能。命令管道是一种通过将多个命令打包发送以减少网络延迟的技术，而实例分片是将数据分散到多个 Redis 实例中以实现水平扩展。
- 
bgsave这种fork子线程不占用IO线程，IO线程常用于处理客户端的写请求，如果要处理读，则配置io-threads-do-reads
### io-threads

设置IO线程数，默认不启用，只使用一个核心线程。

仅在实际遇到性能问题时才启用 I/O 线程，例如 Redis 实例占用大量 CPU 时间。如果 Redis 的 CPU 使用率较低，则无需启用此功能。

线程数配置经验值：
留一核给核心线程，可以设置n-1核，最好n-2，考虑fork子线程bgsave后台保存等
如果是4核以上，配置2-3核。8核则配置6核



### io-threads-do-reads

io线程处理读取操作是否线程化。默认IO线程只处理写操作，因为写比较慢。

此配置不能运行时更改

- 当 `io-threads` 设置为 1 时，Redis 将仅使用主线程进行所有操作，这与默认的单线程模式相同。
- **默认情况下仅对写操作使用 I/O 线程**：当启用 I/O 线程（`io-threads` > 1）时，Redis 会将写操作（如 `write(2)` 系统调用和将客户端缓冲区数据传输到 socket）分配到多个线程中，以提高写操作的性能。

## Append only file

Redis 默认使用 RDB 持久化模式，它会定期将数据集异步地保存到磁盘上的一个二进制文件（`dump.rdb`）中。这种模式的优点是简单高效，但存在一定的数据丢失风险：
- **优点**：RDB 文件是一个紧凑的二进制文件，适合用于备份和灾难恢复。它通过 fork 子进程的方式进行持久化，不会阻塞主线程的正常操作。
- **缺点**：如果 Redis 进程崩溃或发生电源故障，可能会丢失最近几分钟的数据（具体取决于配置的保存点）。例如，如果配置了每 5 分钟保存一次 RDB 文件，那么在发生故障时可能会丢失最多 5 分钟的数据。

AOF则是一共可替代的更好持久化方式：
- **工作原理**：AOF 通过将每个**写操作追加到一个日志文件**中来记录数据的变化。当 Redis 重新启动时，它会**重新执行 AOF 文件中的所有命令来重建数据集**。
- **默认配置**：AOF 的默认 `fsync` 策略是每秒同步一次数据到磁盘。在这种情况下，即使发生服务器电源故障，最多只会丢失 1 秒的数据。如果只是 Redis 进程崩溃，但操作系统仍然正常运行，在单线程写下（IO thread = 1），那么最多只会丢失一个写操作。

AOF可以和RDB持久化同时开启。AOF开启后，redis启动会导入文件

Redis 的 AOF（Append Only File）文件是**文本格式**的，而不是二进制格式。AOF 文件记录了 Redis 服务器接收到的所有写操作命令，这些命令以 Redis 协议的格式存储在文件中。

### write和fsync的区别

`fsync()` 是一个系统调用，用于告诉操作系统立即将缓冲区中的数据写入磁盘，而不是等待更多数据填充缓冲区。不同操作系统的实现方式可能不同：
- 有些操作系统会立即将数据写入磁盘。
- 有些操作系统会尽量尽快完成这一操作，但不保证立即执行。
**fsync是在主线程中调用！而不会起子线程**

`fsync` 是一个**阻塞操作**，**它会等待数据实际写入磁盘后才返回**。如果 `fsync` 在后台线程中执行，主线程仍然需要等待 `fsync` 完成，因为：
- **数据完整性**：Redis 需要确保数据在写入磁盘后才返回给客户端，以保证数据的持久性。
- **同步问题**：如果 `fsync` 在后台线程中执行，主线程可能会在 `fsync` 完成之前继续处理其他写操作，这可能导致数据顺序不一致或数据丢

write（2）则可以是IO线程执行

#### wirte系统调用
`write(2)` 是一个 POSIX 标准的系统调用，用于将**数据从用户空间的缓冲区写入到文件描述符**（如文件、管道或套接字）中。在 Redis 中，`write(2)` **主要用于将数据写入到操作系统的缓冲区**中。

 **特点**
- **非阻塞**：`write(2)` 通常是非阻塞的，它将数据写入到操作系统的缓冲区后立即返回，不会等待数据实际写入到磁盘。
- **性能高**：由于数据只是写入到操作系统的缓冲区，而不是直接写入磁盘，因此 `write(2)` 的性能非常高。
- **数据安全性低**：如果系统崩溃或电源故障，缓冲区中的数据可能会丢失。

#### **`fsync()` 系统调用**

`fsync()` 是一个 POSIX 标准的系统调用，用于**强制操作系统将文件的缓冲区数据同步到磁盘**。在 Redis 中，`fsync()` 用于确保数据真正写入到磁盘，从而提高数据的持久性。

 **特点**
- **阻塞**：`fsync()` 是阻塞的，它会等待数据实际写入到磁盘后才返回。因此，`fsync()` 的调用会显著增加 I/O 等待时间。
- **性能低**：由于 `fsync()` 需要等待数据实际写入磁盘，因此它的性能比 `write(2)` 低。
- **数据安全性高**：`fsync()` 确保数据真正写入到磁盘，因此在系统崩溃或电源故障时，数据不会丢失。

#### **Redis 中的使用场景**
Redis 在 AOF（Append Only File）持久化模式下使用 `write(2)` 和 `fsync()` 来确保数据的持久性。具体使用场景如下：

 **`write(2)` 的使用**
- **写入操作**：每次 Redis 收到一个写操作（如 `SET`、`INCR` 等），它会将该操作追加到 AOF 文件中。这个过程使用 `write(2)` 将数据写入到操作系统的缓冲区。
- **性能优化**：`write(2)` 的使用确保了 Redis 的写操作可以快速完成，不会因为磁盘 I/O 而阻塞主线程。
    
 **`fsync()` 的使用**
- **数据同步**：Redis 提供了三种 `appendfsync` 配置选项，用于控制 `fsync()` 的调用频率：
    - **`no`**：不调用 `fsync()`，完全依赖操作系统来决定何时将数据从缓冲区写入磁盘。这种方式性能最高，但数据安全性最低。
    - **`always`**：每次写操作后立即调用 `fsync()`，确保数据立即写入磁盘。这种方式数据安全性最高，但性能最低。
    - **`everysec`**：每秒调用一次 `fsync()`，无论是否有新的写操作。这种方式在性能和数据安全性之间取得了较好的平衡。
### appendonly

是否开启AOP

### appendfilename

AOF命令日志文件名

### appendfsync

fsync的方式
- always：每次写入AOF后，都执行fsync，开销最大，但是数据不容易
- everysec：每秒执行
- no： 操作系统自行判断来执行，一般30S
### no-appendfsync-on-rewrite

fsync是主线程调用！

当appendfsync为always和everysec时，因为会频繁调用fsycn操作，定期将数据写入磁盘中，可能会遇到性能瓶颈。特别是此时redis还在执行后台保存操作。例如BGSave，BGREWRITEAOF，这些操作都会占用大量磁盘IO，会导致fsync阻塞了main进程。

no-appendfsync-on-rewrite
- **`no`**（默认值）：在后台保存操作进行时，仍然会调用 `fsync()`。这是最安全的选项，从数据持久化的角度来看，但可能会导致性能问题。
- **`yes`**：在后台保存操作进行时，暂停 `fsync()` 调用。这可以减少主线程的阻塞时间，从而缓解性能问题。



### auto-aof-rewrite-percentage

AOF本质上是添加写操作日志到文件中，时间长了后文件可能会变得很大，因此需要除非重写。

AOF重写原理：BGREWRITEAOF
1. fork子线程执行
2. 将数据库当前存储数据转为写操作（最小数据集），写入到新文件中
3. 新文件生成后，再替换旧文件

redis启动时候，会记录AOF文件大小，记为base size

自动重写 AOF 的工作原理
1. **基础大小（Base Size）**：
    - Redis 记录**最后一次重写后 AOF 文件的大小**。如果自启动以来尚未进行过重写，则使用启动时的 AOF 文件大小作为基础大小。
2. **当前大小（Current Size）**：
    - Redis 定期检查当前 AOF 文件的大小，并将其与基础大小进行比较。   
3. **触发条件**：
    - 如果当前 AOF 文件的大小**超过了基础大小的指定百分比**，并且当前 **AOF 文件的大小至少达到了最小重写大小**，则触发重写操作。

两个配置项，控制AOF重写触发
auto-aof-rewrite-percentage：增长比例
auto-aof-rewrite-min-size：增长最小大小mb

### aof-load-truncated

如果开启了AOF，redis启动时候会自动导入AOF文件。但AOF可能出现文件被阶段的情况，导致数据出现异常，从而失败。

AOF 文件被截断的原因
- **系统崩溃**：如果 Redis 所在的系统突然崩溃（如电源故障或内核崩溃），可能会导致 AOF 文件的写入操作未能完成，从而出现文件被截断的情况。
- **文件系统问题**：某些文件系统配置（如 ext4 文件系统未启用 `data=ordered` 选项）可能会增加 AOF 文件被截断的风险。

redis提供处理方式，作为配置
 **`aof-load-truncated yes`**
- **行为**：当 Redis 启动时，如果发现 AOF 文件被截断，Redis 会加载尽可能多的数据，并启动服务器。同时，Redis 会记录一条日志，通知用户 AOF 文件被截断的事件。
- **优点**：服务器可以正常启动，数据丢失最小化。
- **缺点**：可能会丢失 AOF 文件末尾的一些数据。
 **`aof-load-truncated no`**
- **行为**：当 Redis 启动时，如果发现 AOF 文件被截断，Redis 会报错并拒绝启动。
- **优点**：确保数据的完整性，避免加载不完整或损坏的数据。
- **缺点**：需要手动修复 AOF 文件后才能重启 Redis 服务器。

## slow log

redis可以配置慢日志，用于记录查询慢的命令，不包含消息传递等时间，只是命令的执行时间。
可以配置两个参数
- 慢查询时间阈值
- 慢日志大小，大于后会覆盖就命令

### 使用方法

1. **查看慢查询日志**：
    - 使用 `SLOWLOG GET` 命令可以查看当前的慢查询日志。例如：
        
        ```bash
        redis-cli SLOWLOG GET
        ```
        这将返回最近的慢查询日志条目。   

2.  **重置慢查询日志**：
    
    - 使用 `SLOWLOG RESET` 命令可以清空当前的慢查询日志，释放占用的内存。例如：
        ```bash
        redis-cli SLOWLOG RESET
		```


### slowlog-log-slower-than

慢查询时间阈值，毫秒

### slowlog-max-len

慢日志最大命令条目，超限后，覆盖旧命令


## LATENCY MONITOR

redis自带延迟监控系统。这里的延迟指的是Redis命令从开始执行到执行完成所花费的时间。
具体来说，延迟是指 Redis 服务器处理某个命令所需的时间，包括以下几个阶段：
1. **命令解析**：Redis 服务器解析客户端发送的命令。
2. **命令执行**：Redis 执行命令并生成结果。
3. **结果返回**：Redis 将结果发送回客户端。

### 延迟的测量方法

Redis 的延迟监控系统通过以下方式测量延迟：
- **采样**：Redis 会定期采样不同的命令，记录它们的执行时间。
- **阈值**：通过 `latency-monitor-threshold` 配置项，可以设置一个阈值（以毫秒为单位）。只有执行时间超过这个阈值的命令才会被记录。

### 延迟监控的工作原理
1. **采样和数据收集**：
    - Redis 的延迟监控子系统会实时采样不同的操作，记录这些操作的执行时间。
        
    - 通过设置 `latency-monitor-threshold`，可以指定记录操作的最小延迟阈值（以毫秒为单位）。    
2. **延迟报告**：
    - 使用 `LATENCY` 命令可以获取延迟监控的数据。例如：
        - `LATENCY LATEST`：显示最近的延迟数据。
        - `LATENCY HISTORY <event>`：显示指定事件的历史延迟数据。
        - `LATENCY RESET`：重置延迟监控数据。
3. **性能影响**：
    - 延迟监控功能会对性能产生一定的影响，尽管这种影响通常很小，但在高负载下可能会被检测到。

### 为什么关注延迟？

延迟是衡量 Redis 性能的重要指标之一。高延迟可能表明 Redis 服务器在处理某些命令时存在性能瓶颈，或者系统资源（如 CPU、内存、磁盘 I/O）不足。通过监控延迟，可以：
- **优化性能**：找出并优化执行时间较长的命令。
- **诊断问题**：识别系统中的潜在问题，如磁盘 I/O 阻塞、网络延迟等。
- **提高用户体验**：确保 Redis 服务器能够快速响应客户端请求。
### latency-monitor-threshold

配置为0表示关闭


## 扩展

#### AOF文件损坏了如何修复？

如果 Redis 的 AOF 文件损坏了，可以按照以下步骤进行修复：
1.确认 AOF 文件损坏
启动 Redis 时，如果遇到以下错误信息，说明 AOF 文件可能损坏：
Bad file format reading the append only file

2.备份 AOF 文件
在进行任何修复操作之前，建议先备份当前的 AOF 文件，以防止数据丢失：
bash复制，找到AOF文件位置
cp appendonly.aof appendonly.aof.bak

使用 redis-check-aof 工具修复
Redis 提供了 redis-check-aof 工具用于修复损坏的 AOF 文件。以下是修复步骤：
（1）找到 AOF 文件路径
AOF 文件的路径通常在 Redis 配置文件 redis.conf 中指定。可以通过以下命令查看：
bash复制
cat /path/to/redis.conf | grep appendonly

（2）执行修复命令

使用以下命令修复 AOF 文件：
bash复制
redis-check-aof --fix /path/to/appendonly.aof
修复过程中，工具会尝试移除损坏的部分，并生成一个修复后的文件。

（3）确认修复结果
修复完成后，工具会输出修复结果，例如：
Successfully truncated AOF

4. 重启 Redis 服务
修复 AOF 文件后，重启 Redis 服务以验证是否可以正常启动：
bash复制
redis-server /path/to/redis.conf

如果 Redis 成功启动，说明 AOF 文件已修复。
5. 验证数据完整性

修复后的 AOF 文件可能会丢失部分数据，可以通过以下方式验证数据完整性：
使用 redis-cli 连接 Redis，检查关键数据是否存在。
如果有备份的 AOF 文件，可以使用 diff 命令对比修复前后的文件差异：

bash复制
diff -u appendonly.aof appendonly.aof.bak

6. 预防措施

为了避免 AOF 文件再次损坏，可以采取以下措施：

确保正常关闭 Redis 服务：使用 redis-cli shutdown 命令关闭 Redis，避免直接强制停止。
定期检查磁盘健康：确保磁盘没有硬件故障。
合理配置 AOF：调整 appendfsync 配置，避免过于频繁的写入操作。
    

7. 替代方案

如果 AOF 文件损坏严重且无法修复，可以尝试以下替代方案：

从 RDB 文件恢复：如果同时启用了 RDB 持久化，可以加载最近的 RDB 文件并重新生成 AOF 文件。
    
关闭 AOF 功能：如果对数据持久化要求不高，可以关闭 AOF 功能，仅使用 RDB 持久化。
    

通过上述步骤，可以有效修复损坏的 AOF 文件，恢复 Redis 服务的正常运行。如果问题仍然存在，建议检查 Redis 日志或联系技术支持获取进一步帮助。


### redis 使用 `LATENCY LATEST` 和 `LATENCY HISTORY` 命令定位延迟问题

#### 1. **启用延迟监控**

在使用 `LATENCY LATEST` 和 `LATENCY HISTORY` 命令之前，需要先启用 Redis 的延迟监控功能。可以通过以下命令设置延迟监控的阈值：

bash复制

```bash
CONFIG SET latency-monitor-threshold 100
```

这将监控所有执行时间超过 100 毫秒的操作。

#### 2. **使用 `LATENCY LATEST` 查看最新的延迟事件**

`LATENCY LATEST` 命令用于查看最近记录的延迟事件。每个事件包含以下字段：
- **事件名称**：例如 `command`、`fork` 等。
- **时间戳**：事件发生的时间（Unix 时间戳）。
- **最新延迟**：该事件的最新延迟时间（毫秒）。
- **最大延迟**：自 Redis 实例启动以来该事件的最大延迟时间。
    
**示例输出**：

```plaintext
127.0.0.1:6379> latency latest
1) 1) "command"
   2) (integer) 1405067976
   3) (integer) 251
   4) (integer) 1001
```

- **事件名称**：`command`
- **时间戳**：`1405067976`
- **最新延迟**：`251` 毫秒
- **最大延迟**：`1001` 毫秒。

#### 3. **使用 `LATENCY HISTORY` 查看历史延迟数据**

`LATENCY HISTORY` 命令用于查看指定事件的历史延迟数据。该命令返回一个数组，每个元素包含两个值：时间戳和延迟时间。

**示例输出**：


```plaintext
127.0.0.1:6379> latency history command
1) 1) (integer) 1405067822
   2) (integer) 251
2) 1) (integer) 1405067941
   2) (integer) 1001
```

- **时间戳**：`1405067822`
- **延迟时间**：`251` 毫秒。

#### 4. **进一步定位延迟问题**

通过 `LATENCY LATEST` 和 `LATENCY HISTORY` 命令，可以确定哪些操作导致了延迟。以下是一些常见的延迟事件及其含义：

- **`command`**：普通命令的执行时间。
- **`fast-command`**：O(1) 和 O(log N) 命令的执行时间。
- **`fork`**：`fork(2)` 系统调用的执行时间。
- **`aof-fsync-always`**：AOF 持久化中 `fsync(2)` 的执行时间。
- RDB | AOF等命令事件

如果发现某个事件的延迟时间异常高，可以进一步分析：
- **命令执行时间**：如果 `command` 事件的延迟时间高，可能是某些命令执行时间过长。可以通过 `SLOWLOG` 命令查看慢查询日志，优化命令。
- **系统调用时间**：如果 `fork` 或 `fsync` 事件的延迟时间高，可能是系统资源不足或磁盘 I/O 阻塞。
    
#### 5. **优化建议**

根据延迟监控的结果，可以采取以下措施优化 Redis 性能：

- **优化命令执行时间**：减少执行时间较长的命令的使用，或优化命令的参数。
    
- **增加系统资源**：如果系统调用时间过长，可能需要增加 CPU 或内存资源。
    
- **调整持久化策略**：如果 AOF 持久化导致延迟，可以调整 `appendfsync` 配置。
    

通过启用延迟监控并分析 `LATENCY LATEST` 和 `LATENCY HISTORY` 的输出，可以有效定位和优化 Redis 的延迟问题。

#### redis中常见事件：
1. **`command`**：
    - **描述**：监控普通命令的执行时间。
    - **用途**：用于检测执行时间较长的命令。
        
2. **`fast-command`**：
    
    - **描述**：监控时间复杂度为 O(1) 和 O(log N) 的命令的执行时间。
        
    - **用途**：用于检测即使是快速命令也可能出现的延迟问题。
        
3. **`fork`**：
    
    - **描述**：监控 `fork(2)` 系统调用的执行时间。
        
    - **用途**：用于检测在执行 `BGSAVE` 或 `BGREWRITEAOF` 时的延迟。
        
4. **`rdb-unlink-temp-file`**：
    
    - **描述**：监控 `unlink(2)` 系统调用的执行时间，通常用于删除临时 RDB 文件。
        
    - **用途**：用于检测在 RDB 持久化过程中可能出现的文件删除延迟。
        
5. **`aof-write`**：
    
    - **描述**：监控写入 AOF 文件的 `write(2)` 系统调用的执行时间。
        
    - **用途**：用于检测 AOF 持久化过程中的写入延迟。
        
6. **`aof-fsync-always`**：
    
    - **描述**：监控在 `appendfsync always` 策略下 `fsync(2)` 系统调用的执行时间。
        
    - **用途**：用于检测 AOF 持久化中 `fsync` 操作的延迟。
        
7. **`aof-write-pending-fsync`**：
    
    - **描述**：监控在有挂起的 `fsync` 操作时 `write(2)` 系统调用的执行时间。
    - **用途**：用于检测 AOF 持久化中写入操作的延迟。
        
8. **`aof-write-active-child`**：
    
    - **描述**：监控在有活动子进程时 `write(2)` 系统调用的执行时间。
        
    - **用途**：用于检测 AOF 持久化中写入操作的延迟。
        
9. **`aof-write-alone`**：
    
    - **描述**：监控在没有挂起的 `fsync` 操作且没有活动子进程时 `write(2)` 系统调用的执行时间。
        
    - **用途**：用于检测 AOF 持久化中写入操作的延迟。
        
10. **`aof-fstat`**：
    
    - **描述**：监控 `fstat(2)` 系统调用的执行时间。
        
    - **用途**：用于检测文件状态查询操作的延迟。
        
11. **`aof-rename`**：
    
    - **描述**：监控在完成 `BGREWRITEAOF` 后重命名临时文件的 `rename(2)` 系统调用的执行时间。
        
    - **用途**：用于检测 AOF 文件重命名操作的延迟。
        
12. **`aof-rewrite-diff-write`**：
    
    - **描述**：监控在执行 `BGREWRITEAOF` 时写入差异的执行时间。
        
    - **用途**：用于检测 AOF 重写过程中写入操作的延迟。
        
13. **`active-defrag-cycle`**：
    
    - **描述**：监控主动碎片整理周期的执行时间。
        
    - **用途**：用于检测内存碎片整理操作的延迟。
        
14. **`expire-cycle`**：
    - **描述**：监控过期键的周期性检查的执行时间。
    - **用途**：用于检测过期键处理操作的延迟。
        
15. **`eviction-cycle`**：
    - **描述**：监控逐出键的周期性检查的执行时间。
    - **用途**：用于检测内存逐出操作的延迟。
        
16. **`eviction-del`**：
    - **描述**：监控在逐出周期中删除键的执行时间。
    - **用途**：用于检测逐出操作中删除键的延迟。